<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <script type="text/javascript" src="XAudioJS/swfobject.js"></script>
    <script type="text/javascript" src="XAudioJS/resampler.js"></script>
    <script type="text/javascript" src="XAudioJS/XAudioServer.js"></script>
    <script type="text/javascript" src="libmpg123.js"></script>
  </head>
  <body>
    <form action=""><input type="file" /></form>
    <script type="text/javascript">
      //Module.TOTAL_MEMORY = 

      // libmpg123 constants
      var MPG123_DONE = -12;
      var MPG123_NEW_FORMAT = -11;
      var MPG123_NEED_MORE = -10;
      var MPG123_ERR = -1;
      var MPG123_OK = 0;
      // enum mpg123_channelcount
      var MPG123_MONO = 1;
      var MPG123_STEREO = 2;
      //
      var MPG123_ENC_FLOAT_32 = 0x200;

      // libc
      var malloc = Module.cwrap('malloc', 'number', ['number']);
      var free = Module.cwrap('free', 'void', ['number']);

      // create proxy functions that we can call from JavaScript
      var mpg123_init = Module.cwrap('mpg123_init', 'number', []);
      var mpg123_exit = Module.cwrap('mpg123_exit', 'void', []);
      var mpg123_new = Module.cwrap('mpg123_new', 'number', ['string', 'number']);
      var mpg123_delete = Module.cwrap('mpg123_delete', 'void', ['number']);

      var mpg123_supported_decoders = Module.cwrap('mpg123_supported_decoders', 'number', []);

      var mpg123_open_feed = Module.cwrap('mpg123_open_feed', 'number', ['number']);
      var mpg123_read = Module.cwrap('mpg123_read', 'number', ['number', 'number', 'number', 'number']);
      var mpg123_feed = Module.cwrap('mpg123_feed', 'number', ['number', 'number', 'number']);

      var mpg123_getformat = Module.cwrap('mpg123_getformat', 'number', ['number', 'number', 'number']);

      var mpg123_format_none = Module.cwrap('mpg123_format_none', 'number', ['number']);
      var mpg123_format = Module.cwrap('mpg123_format', 'number', ['number', 'number', 'number', 'number']);
      var mpg123_rates = Module.cwrap('mpg123_rates', 'void', ['number', 'number']);



      // XXX: better way to get these sizes?
      var sizeof = {
        'int': 4,
        'pointer': 4
      };



      // return value
      var r;

      // init
      r = mpg123_init();
      //assert.equal(0, r, 'mpg123_init() failed: ' + r);


      // get an array of the "supported decoders"
      var decodersPtr = mpg123_supported_decoders();
      var decoders = [];
      while (true) {
        var decoder = Module.getValue(decodersPtr, 'i32');
        if (0 === decoder) {
          // got NULL pointer
          break;
        }
        decodersPtr += 4;
        decoders.push(Module.Pointer_stringify(decoder));
      }
      console.error('supported decoders:', decoders);


      // get an array of the "sample rates"
      var ratesListPtrPtr = malloc(8);
      var numberPtr = malloc(8);
      mpg123_rates(ratesListPtrPtr, numberPtr);
      var number = Module.getValue(numberPtr, 'i32');
      var rates = [];
      var ratesListPtr = Module.getValue(ratesListPtrPtr, 'i32');
      for (var i = 0; i < number; i++) {
        var cur = Module.getValue(ratesListPtr, 'i32');
        rates.push(cur);
        ratesListPtr += 4;
      }
      console.error('rates:', rates);
      //var number = Module.getValue(numberPtr, 'i32');


      // create an mpg123 decoder handle
      var errorPtr = malloc(sizeof.int);
      var mh = mpg123_new(0, errorPtr);
      var error = Module.getValue(errorPtr, 'i32');
      //assert.equal(0, error, 'mpg123_new() failed: ' + error);
      // ask for "float" output only
      r = mpg123_format_none(mh);
      rates.forEach(function(rate){
        r = mpg123_format(mh, rate, MPG123_MONO | MPG123_STEREO, MPG123_ENC_FLOAT_32);
      });

      // open the "feed" - tell mpg123 that we're going to feed to buffers manually
      r = mpg123_open_feed(mh);
      //assert.equal(0, r, 'mpg123_open_feed() failed: ' + r);

      // upon `stdin` "data" events, invoke `mpg123_feed()` and `mpg123_read()`
      function processBuffer (buf) {
        console.error('process.stdin "data" event (%d bytes)', buf.length);

        var bufPtr = malloc(buf.length);
        Module.writeArrayToMemory(buf, bufPtr);

        // feed
        r = mpg123_feed(mh, bufPtr, buf.length);
        //assert.equal(0, r, 'mpg123_feed() failed: ' + r);
        free(bufPtr);

        var donePtr = malloc(8 /* sizeof size_t */);
        var done;

        var outLen = 8192;
        var outPtr = malloc(outLen);

        while (true) {
          // read

          r = mpg123_read(mh, outPtr, outLen, donePtr);

          if (MPG123_DONE == r) {
            console.log('done!');
            // mp3 is done
            break;
          } else if (MPG123_NEED_MORE == r) {
            console.log('need more!');
            // need more data!
            break;
          } else if (MPG123_NEW_FORMAT === r) {
            // got a new format!
            var ratePtr = malloc(8 /* sizeof long? */);
            var channelsPtr = malloc(8 /* sizeof int */);
            var encodingPtr = malloc(8 /* sizeof int */);

            r = mpg123_getformat(mh, ratePtr, channelsPtr, encodingPtr);
            //assert.equal(0, r, 'mpg123_getformat() failed: ' + r);

            var rate = Module.getValue(ratePtr, 'i32');
            var channels = Module.getValue(channelsPtr, 'i32');
            var encoding = Module.getValue(encodingPtr, 'i32');
            console.log('new format:', {
              rate: rate,
              channels: channels,
              encoding: encoding
            });
            function oncheck (num_bytes) {
              console.log('oncheck', arguments);
              return [];
            }
            function onerror () {
              console.log('onerror', arguments);
            }
            audioHandle = new XAudioServer(channels, rate, rate >> 2, 1024 * 1024, oncheck, 1, onerror);

            continue;
          } else if (MPG123_OK == r) {
            // ok
            done = Module.getValue(donePtr, 'i32');
            console.error('decoded %s bytes!', done);

            //var out = Module.HEAPU8.subarray(outPtr, outPtr + done);
            var floatSamples = new Float32Array(Module.HEAPU8.buffer, outPtr, done / 4 /* sizeof float */);
            console.log(floatSamples.length);

            // convert to float32 samples
            /*
            var intSamples = new Int16Array(out)
              , o = new ArrayBuffer(intSamples.length * 4)
              , floatSamples = new Float32Array(o)
              , f
              , val

            for (var i = 0; i < intSamples.length; i++) {
              f = intSamples[i];
              val = (f + 0.5) / 32767.5;
              console.log(i, f, ' = ', val);
              floatSamples[i] = val;
            }
            */
            //console.log(floatSamples);

            audioHandle.writeAudio(floatSamples);

            //var b = new Buffer(out);
            //console.log(out);
            //process.stdout.write(b);
            //ws.write(b);

          } else {
            // fail
            //assert(0, 'mpg123_read() failed: ' + r);
          }
        }

        free(donePtr);
        free(outPtr);
      }

      //process.stdin.on('end', function(){
      //  console.error('process.stdin "end" event');
      //});

      //process.on('end', close);

      function close () {
        //ws.end();

        // free the "handle" resources
        mpg123_delete(mh);
        free(mh);

        // exit
        //mpg123_exit();
      }

      var audioHandle;
      var input = document.getElementsByTagName('input')[0];
      input.onchange = function (e) {
        var reader = new FileReader();
        reader.onprogress = function (e) {
          console.log('reader.onprogress event', e);
        };
        reader.onload = function (e) {
          console.log('reader.onload event', e);
          var buf = e.target.result;
          var view = new Uint8Array(buf);
          //console.log(view.length);
          var cur;
          var i = 0;
          var chunkSize = 64 * 1024;
          function next () {
            cur = view.subarray(i, i + chunkSize);
            i += chunkSize;
            processBuffer(cur);
            if (i < view.length) {
              setTimeout(next, 100);
            }
          }
          next();

          //close();
          //console.log(buf);
        };
        var file = e.target.files[0];
        console.log('change event', file);
        reader.readAsArrayBuffer(file);
      };
    </script>
  </body>
</html>
